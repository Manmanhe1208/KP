clc
clear
popsize=500;  %种群大小
n=50;
capacity=1000;   %背包大小 可容纳的总重量
% A=load('2-50.txt');
% weight=A(:,2);
% value=A(:,3);
%n=50 c=1000
% weight=[80 82 85 70 72 70 66 50 55 25 50 55 40 48 50 32 22 60 30 32 ...
%         40 38 35 32 25 28 30 22 50 30 45 30 60 50 20 65 20 25 30 10 ...
%     20 25 15 10 10 10 4 4 2 1];       %各个物品的重量，50个个体
% value=[220 208 198 192 180 180 165 162 160 158 155 130 125 122 120 118 115 110 105 101 ...
%         100 100 98 96 95 90 88 82 80 77 75 73 72 70 69 66 65 63 60 58 ...
%         56 50 30 20 15 10 8 5 3 1];     %各个物品的价值，50个个体
%
% n=50 c=1000
weight=[80 82 85 70 72 70 66 50 55 25 50 55 40 48 50 32 22 60 30 32 40 38 35 32 25 28 30 22 25 30 45 30 60 50 20 65 20 25 30 10 20 25 15 10 10 10 4 4 2 1];
value=[220 208 198 192 180 180 165 162 160 158 155 130 125 122 120 118 115 110 105 101 100 100 98 96 95 
90 88 82,80 77 75 73 72 70 69 66 65 63 60 58 56 50 30 20 15 10 8 5 3 1];

%n=100 c=6178
% weight=[54 183 106 82 30 58 71 166 117 190 90 191 20 5 128 110 89 63 6 140 86 30 91 156 31 70 199 142 98 17 8 16 140 31 24 197 101 73 169 73 92 159 71 102 144 15 1 27 131 209 164 177 177 129 146 17 53 164 146 43 170 180 171 130 183 5 113 207 57 13 163 20 63 12 24 9 42 6 109 170 108 46 69 43 175 81 5 34 146 148 114 160 17 4 156 82 47 126 102 83 58 34 21 14];
% value=[597 596 593 586 581 568 567 560 549 548 547 529 529 527 520 491 482 478 475 475 466 462 459 458 454 451 449 443 442 421 410 409 395 394 390 377 375 366 361 347 334 322 315 313 311 309 296 295 294 289 285 279 277 276 272 248 246 245 238 237 232 231 230 225 192 184 183 176 174 171 169 165 165 154 153 150 149 147 143 140 138 134 132 127 124 123 114 111 104 8 9 74 63 62 58 55 48 27 22 12 6];



pc=0.9;   %交叉率
pm=0.05;  %变异率

pop=round(rand(popsize,n)); %产生初始种群  

for i=1:500
    [objvalue]=calobjvalue(pop,n,popsize,value,weight,capacity); %计算目标函数 
    [fitvalue]=calfitvalue(objvalue);   %计算群体中每个个体的适应度 
    [temppop]=selection(pop,fitvalue);   %进行选择计算
    [crosspop]=crossover(temppop,pc);     %进行交叉计算
    [mutationpop]=mutation(crosspop,pm);     %进行变异计算
    [newobjvalue]=newcalobjvalue(mutationpop,n,popsize,value,weight,capacity); %计算最新代目标函数值，经过选择交叉变异后的下一代
    [newfitvalue]=newcalfitvalue(newobjvalue);  %计算最新代的个体适应度
    [bestweight,bestvalue]=best(mutationpop,newfitvalue,weight); %计算最优个体重量，价值，和位置
    y(i)=max(bestvalue);%记录最大价值
    g(i)=max(bestweight);%记录最大重量
    n(i)=i;%记录位置
    pop=mutationpop;%迭代重复         
end

i=1:500;
plot(y(i),'-b*');
xlabel('迭代次数');
ylabel('最大价值');
title('最优点变化趋势');
legend('最优点');
grid on

[z index]=max(y)
%最优代数位置
po=n(index)
%最优重量
W=g(index)
%最优价值
V=z
